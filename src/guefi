#!/usr/bin/env python
# vim:et:sta:sts=4:sw=4:ts=8:tw=79:

from __future__ import print_function
import subprocess
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
import os
import sys


def efi_name_test(name):
    '''Tests if name is a valid one for an EFI boot entry.'''
    if len(name) == 0:
        return False
    allowed = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.,:;()/ "
    return all(c in allowed for c in name)

class UEFI:

    def __init__(self):
        self.efi_hd, self.efi_partition = self.get_efi_partition()
        self.update()

    def get_efi_partition(self):
        dev_nodes = os.listdir('/dev/')
        numbers = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')
        hd = None
        for i in dev_nodes:
            if i.startswith('sd'):
                if not i.endswith(numbers):
                    hd = '/dev/'+i
                    break
        if hd:
            p = subprocess.Popen(['gdisk', '-l', hd], stdout=subprocess.PIPE)
            output = p.communicate()[0].splitlines()
            retval = p.returncode
            if retval == 0:
                for line in output:
                    if ' EF00 ' in line:
                        partition = line.lstrip(' ').partition(' ')[0]
                        return hd,partition
            else:
                return None
        else:
            return None

    def get_efi_mountpoint(self):
        partition = "%s%s" % (self.efi_hd, self.efi_partition)
        p = subprocess.Popen(['findmnt', partition],
                stdout=subprocess.PIPE)
        output = p.communicate()[0].splitlines()
        retval = p.returncode
        if retval == 0:
            for line in output:
                if partition in line:
                    return line.partition(' ')[0]
        else:
            return None

    def add_entry(self, entry):
        self.entries_list.append(entry)

    def create_entry(self, name, loader=None):
        if loader:
            cmd = ['efibootmgr', '-c', '-d', self.efi_hd, '-l', loader,
                    '-p', self.efi_partition, '-L', name]
        else:
            cmd = ['efibootmgr', '-c', '-d', self.efi_hd,
                    '-p', self.efi_partition, '-L', name]
        return subprocess.call(cmd)

    def delete_entry(self, number):
        for i in self.entries_list:
            if i.number == number:
                self.entries_list.pop(self.entries_list.index(i))
                break

    def set_timeout(self, timeout):
        p = subprocess.Popen(['efibootmgr', '-t', timeout])
        return p.returncode

    def delete_timeout(self):
        p = subprocess.Popen(['efibootmgr', '-T'])
        return p.returncode

    def update(self):
        self.entries_list = []
        self.boot_order = []
        self.boot_current = None
        self.boot_next = None
        self.timeout = 0
        self.efi_mountpoint = self.get_efi_mountpoint()
        p = subprocess.Popen('efibootmgr', stdout=subprocess.PIPE)
        output = p.communicate()[0].splitlines()
        retval = p.returncode
        if retval == 0:
            for line in output:
                part1 = line.partition(' ')[0]
                part2 = line.partition(' ')[2]
                if part1.startswith('BootCurrent:'):
                    self.boot_current = part2
                elif part1.startswith('BootNext:'):
                    self.boot_next = part2
                elif part1.startswith('BootOrder:'):
                    for i in part2.split(','):
                        self.boot_order.append(i)
                elif part1.startswith('Timeout:'):
                    self.timeout = part2.partition(' sec')[0]
                elif part1.startswith('Boot'):
                    if part1.endswith('*'):
                        enabled = True
                        number = part1.partition('*')[0].partition('Boot')[2]
                    else:
                        enabled = False
                        number = part1.partition('Boot')[2]
                    name = part2
                    entry = Entry(number, name, enabled)
                    self.add_entry(entry)
        return retval

class Entry:

    def __init__(self, number, name, loader='\elilo.efi', enabled=True, boot_next=False):
        self.number = number
        self.name = name
        self.enabled = enabled
        self.loader = loader
        self.boot_next = boot_next


    def activate(self, number):
        p = subprocess.Popen(['efibootmgr', '-a', '-b', self.number])
        return p.returncode

    def deactivate(self):
        p = subprocess.Popen(['efibootmgr', '-A', '-b', self.number])
        return p.returncode

    def delete(self):
        p = subprocess.Popen(['efibootmgr', '-B', '-b', self.number])
        return p.returncode


class GUEFI:

    #
    # Main window actions
    #
    def gtk_main_quit(self, widget, data=None):
        Gtk.main_quit()

    def on_button_add_clicked(self, widget):
        self.dialog_add.show()

    def on_button_edit_clicked(self, widget):
        pass

    def on_button_remove_clicked(self, widget):
        selectedline = self.treeview_entries.get_selection()
        self.liststore_entries, iter = selectedline.get_selected()
        name = self.liststore_entries.get_value(iter, 0)
        number = self.liststore_entries.get_value(iter, 1)
        dialog = Gtk.MessageDialog(self.window, 0, Gtk.MessageType.QUESTION,
                Gtk.ButtonsType.YES_NO,
                "Are you sure you want to remove this EFI boot entry?")
        dialog.set_modal(self.window)
        name_string = "%s: %s" % ("Name", name)
        number_string ="%s: %s" % ("Number", number)
        dialog.format_secondary_text("%s\n%s" % (name_string, number_string))
        response = dialog.run()
        if response == Gtk.ResponseType.YES:
            p = subprocess.call(['efibootmgr', '-B', '-b', number])
        dialog.destroy()
        self.update_list()
        if p != 0:
            msg = "Could not delete boot entry"
            dialog = Gtk.MessageDialog(self.window, 0, Gtk.MessageType.ERROR,
                                Gtk.ButtonsType.OK, msg)
            dialog.set_modal(self.window)
            dialog.run()
            dialog.destroy()

    def on_button_move_up_clicked(self, widget):
        pass

    def on_button_move_down_clicked(self, widget):
        pass

    def on_button_apply_clicked(self, widget):
        boot_order = []
        for i in self.liststore_entries:
            boot_order.append(i[1])
        cmd = ['efibootmgr', '-o', ','.join(boot_order)]
        p = subprocess.Popen(cmd)
        print(p.returncode)

    def on_cellrenderertoggle_boot_next_toggled(self, widget, data=None):
        pass

    def on_cellrenderertoggle_enabled_toggled(self, widget, data=None):
        pass

    #
    # Add dialog actions
    #
    def on_button_add_ok_clicked(self, widget):
        new_name = self.entry_add_name.get_text()
        if not self.new_loader:
            msg = "No EFI loader has been selected"
            dialog = Gtk.MessageDialog(self.dialog_add, 0, Gtk.MessageType.ERROR,
                                Gtk.ButtonsType.OK, msg)
            dialog.set_modal(self.dialog_add)
            dialog.run()
            dialog.destroy()
        elif not efi_name_test(new_name):
            msg = "Invalid name. Only these characters are allowed: A-Z a-z 0-9 .,:;-()/ and space. "
            dialog = Gtk.MessageDialog(self.dialog_add, 0, Gtk.MessageType.ERROR,
                                Gtk.ButtonsType.OK, msg)
            dialog.set_modal(self.dialog_add)
            dialog.run()
            dialog.destroy()
        else:
            p = self.uefi.create_entry(new_name, self.new_loader)
            if p != 0:
                msg = "Something went wrong. Could not create new boot entry"
                dialog = Gtk.MessageDialog(self.dialog_add, 0, Gtk.MessageType.ERROR,
                                    Gtk.ButtonsType.OK, msg)
                dialog.set_modal(self.dialog_add)
                dialog.run()
                dialog.destroy()
            else:
                print('done')
                self.update_list()
                self.dialog_add.hide()


    def on_button_add_cancel_clicked(self, widget):
        self.entry_loader_path.set_text('')
        self.new_loader = None
        self.dialog_add.hide()

    # this runs whenever a new file is selected through the filechooser dialog
    def on_filechooserbutton_loader_file_set(self, widget):
        filename = self.filechooserbutton_loader.get_filename()
        basename = os.path.basename(filename)
        if filename.startswith(self.uefi.efi_mountpoint):
            path = filename.partition(self.uefi.efi_mountpoint)[2].partition(basename)[0]
            self.entry_loader_path.set_text(path)
            self.new_loader = path+basename
        else:
            # show an error message that warns about the EFI loader location
            msg = "The EFI loader you have selected is not located inside the EFI partition"
            dialog = Gtk.MessageDialog(self.dialog_add, 0, Gtk.MessageType.ERROR,
                                Gtk.ButtonsType.OK, msg)
            dialog.set_modal(self.dialog_add)
            dialog.run()
            self.entry_loader_path.set_text('**%s**' % 'ERROR')
            self.new_loader = None
            dialog.destroy()

    # this checks the validity of the EFI boot entry name:
    def check_efi_name(self, name):
        if len(name) == 0:
            return False
        if match(name):
            return True
        else:
            return False

    # this updates the boot entries list in the main window
    def update_list(self):
        self.liststore_entries.clear()
        self.uefi.update()
        boot_order = self.uefi.boot_order
        # if the boot order does not include all UEFI entries, then append the
        # missing ones at the end of the list
        if len(boot_order) < len(self.uefi.entries_list):
            for i in self.uefi.entries_list:
                if i.number not in boot_order:
                    boot_order.append(i.number)
        # now add everything to the liststore, according to the boot order
        for n in boot_order:
            if n == self.uefi.boot_next:
                boot_next = True
            else:
                boot_next = False
            for j in self.uefi.entries_list:
                if j.number == n:
                    name = j.name
                    enabled = j.enabled
            self.liststore_entries.append([name, n, enabled, boot_next])

    def __init__(self):
        self.uefi = UEFI()

        # this is going to be used to store the path to the EFI loader when
        # the Add and Edit buttons are pressed
        self.new_loader = None

        builder = Gtk.Builder()
        if os.path.exists('guefi.ui'):
            builder.add_from_file('guefi.ui')
        elif os.path.exists('/usr/share/guefi/guefi.ui'):
            builder.add_from_file('/usr/share/guefi/guefi-gtk.ui')
        
        # Main window
        self.window = builder.get_object('guefi')
        self.treeview_entries = builder.get_object('treeview_entries')
        self.liststore_entries = builder.get_object('liststore_entries')
        self.update_list()

        # Add boot entry dialog
        self.dialog_add = builder.get_object('dialog_add')
        self.entry_add_name = builder.get_object('entry_add_name')
        self.entry_loader_path = builder.get_object('entry_loader_path')
        self.filechooserbutton_loader = builder.get_object('filechooserbutton_loader')
        self.filefilter_efi = builder.get_object('filefilter_efi')
        self.filefilter_efi.add_pattern('*.efi')

        if not self.uefi.efi_partition:
            print('No UEFI partition detected. Aborting.')
            sys.exit(1)
        if not self.uefi.efi_mountpoint:
            print('UEFI parition is not mounted. Aborting.')
            sys.exit(1)

        builder.connect_signals(self)

if __name__ == "__main__":
    app = GUEFI()
    app.window.show_all()
    Gtk.main()
